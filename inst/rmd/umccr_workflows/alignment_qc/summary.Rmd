---
author: "University of Melbourne Centre for Cancer Research"
date: "`r Sys.time()`"
output:
  html_document:
    toc: true
    theme: cosmo
  rmdformats::material:
    highlight: kate
params:
  title: "UMCCR Alignment QC Summary Report"
  indir: !r c("/Users/pdiakumis/icav1/g/production/analysis_data/SBJ00006/wgs_alignment_qc/2023120207560682/L2301460__2_dragen",  "/Users/pdiakumis/icav1/g/production/analysis_data/SBJ00006/wgs_alignment_qc/2023120233dd717e/L2301460__1_dragen",  "/Users/pdiakumis/icav1/g/production/analysis_data/SBJ04434/wgs_alignment_qc/202312021b071091/L2301458__2_dragen",  "/Users/pdiakumis/icav1/g/production/analysis_data/SBJ00020/wgs_alignment_qc/2023120232c970f3/L2301459__2_dragen",  "/Users/pdiakumis/icav1/g/production/analysis_data/SBJ04434/wgs_alignment_qc/20231202aade4cdd/L2301458__1_dragen",  "/Users/pdiakumis/icav1/g/production/analysis_data/SBJ04434/wgs_alignment_qc/202312028ade3e75/L2301457__2_dragen",  "/Users/pdiakumis/icav1/g/production/analysis_data/SBJ00020/wgs_alignment_qc/20231202c7409dbb/L2301459__1_dragen",  "/Users/pdiakumis/icav1/g/production/analysis_data/SBJ04434/wgs_alignment_qc/2023120225ef70a8/L2301457__1_dragen",  "/Users/pdiakumis/icav1/g/production/analysis_data/SBJ04411/wgs_alignment_qc/20231202c2a777eb/L2301454__3_dragen",  "/Users/pdiakumis/icav1/g/production/analysis_data/SBJ04411/wgs_alignment_qc/202312022b845cd9/L2301453__4_dragen" )
  subjectid: !r c("SBJ00006", "SBJ00006", "SBJ04434", "SBJ00020", "SBJ04434", "SBJ04434", "SBJ00020", "SBJ04434", "SBJ04411", "SBJ04411")
  sampleid: !r c("NTC_Tsqn231127", "NTC_Tsqn231127", "PRJ231322", "PTC_Tsqn231127", "PRJ231322", "PRJ231321", "PTC_Tsqn231127", "PRJ231321", "PRJ231294", "PRJ231203")
  libraryid: !r c("L2301460", "L2301460", "L2301458", "L2301459", "L2301458", "L2301457", "L2301459", "L2301457", "L2301454", "L2301453")
  lane: !r c("2", "1", "2", "2", "1", "2", "1", "1", "3", "4")
description: "UMCCR Alignment QC Summary Report"
title: "`r params$title`"
---

```{r knitr_opts, include=F}
knitr::opts_chunk$set(
  collapse = TRUE, echo = FALSE,
  warning = FALSE, message = FALSE,
  fig.width = 10, fig.height = 15
)
```

```{css}
.main-container {
  max-width: 1400px !important;
  margin-left: auto;
  margin-right: auto;
}
```

```{r load_pkgs}
{
  require(dplyr)
  require(dracarys)
  require(DT, include.only = "datatable")
  require(glue, include.only = "glue")
  require(here, include.only = "here")
  require(purrr, include.only = "map")
  require(readr, include.only = "read_rds")
  require(tibble, include.only = "tibble")
  require(knitr, include.only = "kable")
  require(ggplot2)
  require(tidyr, include.only = "unnest")
}
```

```{r data_setup}
# source(here::here("inst/rmd/umccr_workflows/alignment_qc/params/pd.R")) # for use with 'Run All Chunks Above'
ggplot2::theme_set(ggplot2::theme_bw())
ptbl <- tibble::as_tibble(params)
stopifnot(all(dir.exists(ptbl$indir)))
options(scipen = 999) # disable scientific notation
options(width = 150)
filepaths <- function(indir, sampleid, lane, suffix = "rds") {
  tibble::tibble(
    ftype = c(
      paste0(
        "FastqcMetricsFile_",
        c(
          "positional_base_content", "positional_base_mean_quality",
          "positional_quality", "read_gc_content", "read_gc_content_quality",
          "read_lengths", "read_mean_quality", "sequence_positions"
        )
      ),
      "FragmentLengthHistFile",
      "MappingMetricsFile",
      "PloidyEstimationMetricsFile",
      "ReplayFile",
      "TimeMetricsFile",
      "TrimmerMetricsFile",
      "WgsContigMeanCovFile",
      "WgsCoverageMetricsFile",
      "WgsFineHistFile",
      "WgsHistFile"
    )
  ) |>
    mutate(
      fpath = file.path(indir, glue("{sampleid}_{.data$ftype}.{suffix}")),
      file_exists = file.exists(.data$fpath)
    )
}

dat <- ptbl |>
  rowwise() |>
  mutate(
    fpaths = list(filepaths(indir = .data$indir, sampleid = .data$sampleid, lane = .data$lane)),
    umccrid = glue("{.data$subjectid}_{.data$libraryid}_LN{.data$lane}")
  ) |>
  select("umccrid", "fpaths") |>
  tidyr::unnest(fpaths) |>
  rowwise() |>
  mutate(
    dat = ifelse(.data$file_exists, list(readr::read_rds(.data$fpath), NULL))
  ) |>
  ungroup()

eval <- dat |>
  group_by(ftype) |>
  count(file_exists, name = "nf") |>
  mutate(eval = nf == nrow(ptbl)) |>
  select("ftype", "eval") |>
  tibble::deframe() |>
  as.list()

# filetype-specific access
d <- dat |>
  select("umccrid", "ftype", "dat") |>
  tidyr::nest(data = c("umccrid", "dat"))
# sample-specific access
d_samp <- dat |>
  select("umccrid", "ftype", "dat") |>
  tidyr::nest(data = c("ftype", "dat")) |>
  arrange("umccrid")
```

```{r funcs}
dr_unnest <- function(x1) {
  d |>
    filter(.data$ftype == x1) |>
    tidyr::unnest(data) |>
    rowwise() |>
    mutate(nrows = nrow(.data$dat)) |>
    ungroup() |>
    filter(nrows > 0) |>
    tidyr::unnest(dat) |>
    select("umccrid", everything(), -c("ftype", "nrows"))
}

dt_view <- function(x, caption = NULL, scroll_y = nrow(ptbl) * 30) {
  num_cols <- names(x)[sapply(x, is.numeric)]
  x |>
    DT::datatable(
      filter = list(position = "top", clear = FALSE, plain = TRUE),
      class = "cell-border display compact",
      rownames = FALSE,
      extensions = c("Scroller", "Buttons", "KeyTable"),
      options = list(
        scroller = TRUE, scrollY = scroll_y, scrollX = TRUE,
        autoWidth = FALSE, keys = TRUE,
        buttons = c("csv", "excel"), dom = "Blfrtip"
      ),
      caption = caption
    ) |>
    DT::formatCurrency(columns = num_cols, currency = "", digits = 1)
}

blank_lines <- function(n = 10) {
  cat(rep("&nbsp;  ", n), sep = "\n")
}
```

## QC Metrics {.tabset .tabset-pills}

### Mapping

```{r mm, eval=eval$MappingMetricsFile}
d1 <- dr_unnest("MappingMetricsFile") |>
  arrange(umccrid) |>
  select(
    umccrid,
    reads_tot_rg_dragen, reads_num_dupmarked_dragen, reads_num_dupmarked_dragen_pct,
    reads_mapped_dragen_pct, reads_unmapped_dragen_pct, reads_num_uniq_dragen_pct,
    reads_num_uniq_mapped_dragen_pct, reads_match_nonref_decoys_adj_dragen_pct,
    reads_singleton_dragen_pct, reads_paired_dragen_pct,
    reads_paired_proper_dragen_pct, reads_discordant_dragen_pct,
    reads_mapq_0_10_dragen, read_len_dragen, insert_len_median_dragen,
    insert_len_mean_dragen, everything()
  )
d1 |>
  dt_view()
```

### Coverage

```{r covm, eval=eval$WgsCoverageMetricsFile}
# TODO: plot cov_genome_pct_<X>_<Y>_dragen
d1 <- dr_unnest("WgsCoverageMetricsFile") |>
  arrange(umccrid) |>
  select(
    umccrid,
    cov_avg_auto_over_genome_dragen,
    cov_median_auto_over_genome_dragen,
    cov_avg_x_over_genome_dragen,
    cov_avg_y_over_genome_dragen,
    everything()
  )
d1 |>
  dt_view()
```

### Ploidy

```{r pe, eval=eval$PloidyEstimationMetricsFile}
# TODO: plot cov_<X>_div_auto_medians_dragen
d1 <- dr_unnest("PloidyEstimationMetricsFile") |>
  arrange(umccrid) |>
  select(
    umccrid, ploidy_est_dragen, cov_auto_median_dragen,
    cov_x_median_dragen, cov_y_median_dragen, everything()
  )
d1 |>
  dt_view()
```

### Trimmer

```{r trim, eval=eval$TrimmerMetricsFile}
d1 <- dr_unnest("TrimmerMetricsFile") |>
  arrange(umccrid) |>
  select(
    umccrid, reads_tot_input_dragen, read_len_avg_dragen,
    reads_trimmed_tot_dragen, reads_trimmed_tot_dragen_pct,
    bases_trimmed_tot_dragen, bases_trimmed_tot_dragen_pct,
    reads_tot_filt_dragen, reads_tot_filt_dragen_pct,
    everything()
  )
d1 |>
  dt_view()
```

### FineHist

```{r finehist, eval=eval$WgsFineHistFile}
d1 <- dr_unnest("WgsFineHistFile")
d1 |>
  WgsFineHistFile$public_methods$plot(c(0, 150)) +
  facet_wrap(~umccrid, scales = "free_y")
```

### Hist

```{r cvgm, eval=eval$WgsCoverageMetricsFile}
d1 <- dr_unnest("WgsHistFile")
d1 |>
  ggplot(aes(x = start, y = pct, colour = umccrid)) +
  geom_point() +
  geom_linerange(aes(xmin = start, xmax = end)) +
  facet_wrap(~umccrid) +
  labs(x = "Coverage range", y = "PCT") +
  ggtitle("PCT of bases with coverage in the given range.") +
  theme(legend.position = "none")
```

-----

## Fragment Length

```{r fraglenhist_plot, eval=eval$FragmentLengthHistFile}
fl1 <- dr_unnest("FragmentLengthHistFile")
min_count <- 10
fl1 |>
  filter(.data$count >= min_count) |>
  ggplot2::ggplot(ggplot2::aes(x = .data$fragmentLength, y = .data$count)) +
  ggplot2::geom_line(aes(colour = umccrid)) +
  ggplot2::labs(title = "Fragment Length Distribution") +
  ggplot2::xlab("Fragment Length (bp)") +
  ggplot2::ylab(glue("Read Count (min: {min_count})")) +
  ggplot2::theme(
    legend.position = c(0.9, 0.9),
    legend.justification = c(1, 1),
    panel.grid.minor = ggplot2::element_blank(),
    plot.title = ggplot2::element_text(colour = "#2c3e50", size = 14, face = "bold")
  )
```

## Coverage {.tabset .tabset-pills}

```{r contig_cvg, eval=eval$WgsContigMeanCovFile, results='asis'}
d1 <- dr_unnest("WgsContigMeanCovFile") |>
  arrange("umccrid")
for (s in sort(unique(d1$umccrid))) {
  p1 <- d1 |>
    filter(umccrid == s) |>
    dracarys::WgsContigMeanCovFile$public_methods$plot() +
    ggplot2::labs(subtitle = s)
  cat(glue("\n### {s}"), "\n")
  blank_lines(2)
  print(p1)
  blank_lines(2)
  cat("\n\n\n")
}
```

## FastQC {.tabset .tabset-pills}

### Positional Base Content ('Per-Position Sequence Content')

```{r fqc_pbc}
f1 <- dr_unnest("FastqcMetricsFile_positional_base_content")
f1 |>
  filter(base != "N") |>
  mutate(prop = prop * 100) |>
  ggplot(aes(x = pos, y = prop, colour = base, group = base)) +
  geom_line() +
  facet_grid(umccrid ~ mate) +
  labs(
    x = "Position in Read (bp)",
    y = "Proportion of Bases",
    title = "Positional Base Content",
    subtitle = glue(
      "Proportion of bases of each specific nucleotide",
      "\nat given locations in the read."
    )
  )
```

### Positional Base Mean Quality ('Per-Position Mean Quality Scores')

```{r fqc_bmq}
f1 <- dr_unnest("FastqcMetricsFile_positional_base_mean_quality")
fqc_colours <- tibble::tibble(
  start = c(0, 20, 28),
  end = c(20, 28, Inf),
  col = c("#e6c3c3", "#e6dcc3", "#c3e6c3")
)
ggplot() +
  geom_rect(
    data = fqc_colours,
    mapping = aes(ymin = start, ymax = end, xmin = -Inf, xmax = Inf),
    fill = rep(fqc_colours$col, length(unique(f1$umccrid)) * length(unique(f1$mate))),
    alpha = 0.4
  ) +
  geom_line(data = f1, aes(x = pos, y = value, colour = base)) +
  facet_grid(umccrid ~ mate) +
  theme_minimal() +
  labs(
    x = "Position in Read (bp)",
    y = "Quality Score",
    title = "Positional Base Mean Quality",
    subtitle = glue(
      "Average Phred-scale quality value of bases with a specific",
      "\nnucleotide and at a given location in the read."
    )
  )
```

### Positional Quality ('Per-Position Quality Score Ranges')

```{r fqc_pq, eval=F}
# TODO: use boxplot instead of point
f1 <- dr_unnest("FastqcMetricsFile_positional_quality")
f1 |>
  mutate(pos = as.integer(.data$pos)) |>
  filter(pct %in% c(25, 50, 75)) |>
  ggplot(aes(x = pos, y = value, colour = mate)) +
  geom_point() +
  facet_wrap(~umccrid) +
  labs(
    title = "Positional Quality",
    subtitle = glue("Phred-scale quality value for bases at a given location and a\ngiven quantile of the distribution")
  )
```

### GC Content ('Per-Sequence GC Content')

```{r read_gc}
f1 <- dr_unnest("FastqcMetricsFile_read_gc_content")
f1 |>
  group_by(umccrid, mate) |>
  mutate(
    tot = sum(.data$value),
    prop = round(.data$value / .data$tot, 3),
    prop = 100 * prop
  ) |>
  ungroup() |>
  ggplot(aes(x = pct, y = prop, colour = mate)) +
  geom_line(aes(linetype = mate), alpha = 0.4, linewidth = 1) +
  facet_wrap(~umccrid) +
  labs(
    x = "GC content",
    y = "Percentage of Reads",
    title = "Read GC Content",
    subtitle = glue("Total number of reads with each GC content\npercentile between 0% and 100%")
  )
```

### GC Content Quality ('GC Content Mean Quality Scores')

```{r read_gc_qual}
f1 <- dr_unnest("FastqcMetricsFile_read_gc_content_quality") |>
  filter(!is.na(.data$value))
ggplot() +
  geom_rect(
    data = fqc_colours,
    mapping = aes(ymin = start, ymax = end, xmin = -Inf, xmax = Inf),
    fill = rep(fqc_colours$col, length(unique(f1$umccrid))),
    alpha = 0.4
  ) +
  geom_line(data = f1, aes(x = pct, y = value, colour = mate)) +
  facet_wrap(~umccrid) +
  labs(
    title = "GC Content Quality",
    subtitle = glue("Average Phred-scale read mean quality for reads with\neach GC content percentile between 0% and 100%.")
  )
```

### Read Lengths ('Sequence Length Distribution')

```{r read_len}
f1 <- dr_unnest("FastqcMetricsFile_read_lengths")
f1 |>
  ggplot(aes(x = bp, y = value, colour = mate)) +
  geom_line(aes(linetype = mate), linewidth = 1) +
  theme(
    panel.grid.major = element_blank()
  ) +
  facet_wrap(~umccrid, scales = "free_y") +
  labs(
    title = "Read Lengths",
    subtitle = glue("Total number of reads with each observed length.")
  )
```

### Read Mean Quality ('Per-Sequence Quality Scores')

```{r read_mean_qual}
f1 <- dr_unnest("FastqcMetricsFile_read_mean_quality")
ggplot() +
  geom_rect(
    data = fqc_colours,
    mapping = aes(xmin = start, xmax = end, ymin = -Inf, ymax = Inf),
    fill = rep(fqc_colours$col, length(unique(f1$umccrid))),
    alpha = 0.4
  ) +
  geom_line(data = f1, aes(x = q, y = value, colour = mate, linetype = mate), linewidth = 1) +
  scale_y_continuous(labels = scales::label_comma()) +
  theme(
    panel.grid.major = element_blank()
  ) +
  facet_wrap(~umccrid, scales = "free_y") +
  labs(
    title = "Read Mean Quality",
    subtitle = glue("Number of reads with average quality scores. Shows if\na subset of reads has poor quality.

")
  )
```

### Sequence Positions

```{r seq_pos}
f1 <- dr_unnest("FastqcMetricsFile_sequence_positions")
"Number of times an adapter or other kmer sequence is found, starting at a given position in the input reads."
```

---

## Addendum {.tabset .tabset-pills}

<details>

<summary>Details</summary>

### Params

```{r params_info}
params |>
  purrr::modify_if(is.null, \(x) "NULL", .else = as.character) |>
  tibble::enframe(name = "Parameter", value = "Value") |>
  tidyr::unnest("Value", keep_empty = TRUE) |>
  knitr::kable()
```

### SessionInfo {.tabset .tabset-pills}

```{r si_prep}
si <- dracarys:::session_info_tbls()
si_pkg <- si$si_pkg
si_pl <- si$si_pl
```

#### Platform

```{r si_pl}
si_pl |>
  knitr::kable()
```

#### Packages

```{r si_pkg}
si_pkg |>
  knitr::kable()
```

#### SysInfo

```{r reporter_details, comment = NA}
tibble::tribble(
  ~Info, ~Value,
  "Node", Sys.info()["nodename"],
  "OS", Sys.info()["sysname"],
  "User", Sys.info()["user"],
) |>
  knitr::kable()
```

</details>

